<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>shell入门之道</title>
    <style type="text/css" media="all">
      body {
        margin: 0;
        font-family: "Helvetica Neue", Helvetica, Arial, "Hiragino Sans GB", sans-serif;
        font-size: 14px;
        line-height: 20px;
        color: #777;
        background-color: white;
      }
      .container {
        width: 700px;
        margin-right: auto;
        margin-left: auto;
      }

      .post {
        font-family: Georgia, "Times New Roman", Times, "SimSun", serif;
        position: relative;
        padding: 70px;
        bottom: 0;
        overflow-y: auto;
        font-size: 16px;
        font-weight: normal;
        line-height: 25px;
        color: #515151;
      }

      .post h1{
        font-size: 50px;
        font-weight: 500;
        line-height: 60px;
        margin-bottom: 40px;
        color: inherit;
      }

      .post p {
        margin: 0 0 35px 0;
      }

      .post img {
        border: 1px solid #D9D9D9;
      }

      .post a {
        color: #28A1C5;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="post">
        <h1 class="title">shell入门之道</h1>
        <div class="show-content">
          <div class="image-package">
<img class="uploaded-img" src="http://upload-images.jianshu.io/upload_images/17609428-e14b810690a3b687.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="auto" height="auto"><br><div class="image-caption"></div>
</div><h1>一前言</h1><h3>1.1什么是shell？</h3><p>Shell是在Linux内核与用户之间的解释器程序，通常指的是bash，负责向内核翻译及传达用户/程序指令</p><p>shell的使用方式：</p><p>1.交互执行指令：人工干预，执行效率低。</p><p>2.非交互执行指令：安静地在后台执行，执行效率高，方便写脚本。</p><h3>2.2shell解释器</h3><p>/bin/sh</p><p>/bin/bash                                   #默认解释器</p><p>/sbin/nologin                            #禁止用户登陆</p><p>/usr/bin/sh</p><p>/usr/bin/bash</p><p>/usr/sbin/nologin                      #禁止用户登陆</p><p>/bin/tcsh</p><p>/bin/csh</p><p>/bin/ksh</p><p>/bin/rksh</p><p>提示：修改默认解释器，在创建(修改)用户指定默认解释器</p><h3>2.3执行注意事项</h3><p>bash     test.sh                #打开子进程执行程序</p><p>./test.sh                           #打开子进程执行程序</p><p>source  test.sh                #不打开子进程执行程序</p><p>例子：</p><p>#vim test.sh</p><p>#!/bin/bash</p><p>sleep 1000</p><h1>二语法</h1><h3>2.1重定向</h3><p>标准输入（stdin），描述号为0；</p><p>标准输出（stdout），描述号为1；</p><p>标准错误（stderr），描述号为2;</p><p>&gt;   :可重定向正确信息</p><p>&gt;&gt; :可实现追加正确信息</p><p>2&gt;  :可重定向错误信息</p><p>2&gt;&gt;  :可实现追加错误信息</p><p>&amp;&gt; :可重定向错误和正确信息</p><p>&gt;&amp;2  :将输出信息转换为错误输出( 即$? != 0)</p><p>例子1：</p><p>[root@server0 ~]# ls /etc/hosts nm.txt &gt;1.txt 2&gt;2.txt</p><p>[root@server0 ~]# cat 1.txt</p><p>/etc/hosts</p><p>[root@server0 ~]# cat 2.txt</p><p>ls:无法访问nm.txt: 没有那个文件或目录</p><p>例子2：</p><p>交互式发邮件</p><p>[root@server0 ~]# mail -s tile root</p><p>非交互式发邮件</p><p>[root@server0 ~]# mail -s title root &lt; /etc/passwd</p><h3>2.2变量</h3><p>掌握并熟悉Shell变量的使用，主要练习或验证下列内容：</p><p>定义/赋值/查看变量</p><p>环境/预定义/位置变量的应用</p><p>除了学会建立和引用变量以外，还要认识环境变量PWD、USER、HOME、SHELL，还有预定义变量$0、$$、$?、$#、$*，以及位置变量$1、$2、$10、……的作用。</p><p><br></p><h4>2.2.1环境变量</h4><p>[root@server0 ~]# env                                        #查看当前系统自带的环境变量</p><p>[root@server0 ~]# set                                         #查看当前系统定义的环境变量(系统自带，自己定义的)</p><p><br></p><p>USER：代表当前用户</p><p>HOME：输出当前用户家目录</p><p>SHELL：代表当前用户所用的解释器</p><p>PWD：当前目录位置</p><p>UID：当前用户的uid</p><p>PATH：</p><p>PS1：设置提示</p><p>例子：</p><p>[root@server0 ~]# PS1=[强哥]#</p><p>[强哥]#exit</p><p>[root@server0 ~]# echo $PS1</p><p>[\u@\h \W]\$</p><p>[root@server0 ~]# echo $PS2</p><p>&gt;</p><h4>2.2.2预定义变量</h4><p>$$：当前进程的进程号</p><p>$?：输出上一个程序的返回状态码</p><p>$#：统计参数的个数</p><p>$*：代表所有参数变量的值</p><p>$$ ：Shell本身的PID（ProcessID）</p><p>$!：Shell最后运行的后台Process的PID</p><p>$?：最后运行的命令的结束代码（返回值）</p><p>$-：使用Set命令设定的Flag一览</p><p>$*：所有参数列表。如"$*"用「"」括起来的情况、以"$1 $2 … $n"的形式输出所有参数。</p><p>$@：所有参数列表。如"$@"用「"」括起来的情况、以"$1" "$2" … "$n" 的形式输出所有参数。</p><p>$#：添加到Shell的参数个数</p><p>$0：Shell本身的文件名</p><p>$1～$n：添加到Shell的各参数值。$1是第1参数、$2是第2参数…。</p><p>例子：</p><p>echo $0                                        //脚本的名称</p><p>echo $1                                        //第一个参数</p><p>echo $2                                        //第二个参数</p><p>echo $*                                        //所有参数</p><p>echo $#                                        //所有的综合</p><p>echo $$                                        //当前进程的进程号</p><p>echo $?                                        //上一个程序的返回状态码</p><p><br></p><h4>2.2.3位置变量</h4><p>$n：表示第几个参数变量</p><p>提示：${10}不能写成$10   $10=${1}0</p><p>例子：</p><p>[root@svr5 ~]#./test.sh  a b c d</p><p>即 $1=a，$2=b，$3=c，$4=d</p><p><br></p><h4>2.2.4变量的定义/赋值/查看/引用</h4><p><b>1，新建/赋值变量</b></p><p>新建变量test，赋值“hello world”，通过set命令可以检查变量设置：</p><p>[root@svr5 ~]# test=11</p><p><b>2，查看变量</b></p><p>通过echo $变量名 可输出变量值：</p><p>[root@svr5 ~]# echo $test</p><p>11</p><p><b>提示：</b></p><p>查看变量时，若变量名称与后面要输出的字符串连在一起，则应该以{}将变量名括起来以便区分。</p><p>[root@svr5 ~]# echo $testRMB              //无法识别变量名test</p><p>[root@svr5 ~]# echo ${test}RMB              //区分后可以识别</p><p>11RMB</p><p><b>3，撤销自定义变量</b></p><p>若要撤销已有的变量，可使用unset命令：</p><p>[root@svr5 ~]# unset test                  //撤销变量test</p><p>[root@svr5 ~]# echo $test                  //查看时已无结果</p><p><b>4，引用</b></p><p>变量的引用使用$符号，多字符需要用{}引起来</p><p>例子：</p><p>[root@svr5 ~]# test=123</p><p>[root@svr5 ~]# echo ${test}520</p><p>123520</p><p><br></p><h4>2.2.5三种引号对变量赋值的影响</h4><p><b>1，双引号的应用</b></p><p>使用双引号可以界定一个完整字符串。</p><p><br></p><p><b>2，单引号的应用</b></p><p>界定一个完整的字符串，并且可以实现屏蔽特殊符号的功能。</p><p><br></p><p><b>3，反撇号或$()的应用</b></p><p>使用反撇号或$()时，可以将命令执行的标准输出作为字符串存储，因此称为命令替换。</p><p>[root@svr5 ~]# tar -czf log-`date +%Y%m%d`.tar.gz /var/log</p><p><br></p><h3>2.3 read基本用法</h3><p>应用于执行后从会等待并接受用户输入（无任何提示的情况），并赋值给变量str</p><p>为了不至于使用户不知所措、莫名其妙，推荐的做法是结合-p选项给出友好提示。</p><p>例子：</p><p>[root@svr5 ~]# read -p "请输入一个整数：" i</p><p>请输入一个整数：240</p><p>[root@svr5 ~]# echo $i</p><p>240</p><h3>2.4stty终端显示控制</h3><p>将回显功能关闭（stty -echo）</p><p>将回显功能恢复（stty echo）</p><p>例子：</p><p>[root@svr5 ~]# vim user.sh              //创建一个测试脚本</p><p>#!/bin/bash</p><p>read -p "请输入用户名:"  username              //读取用户名</p><p>stty -echo                                  //关闭回显</p><p>read -p "请输入密码:"  passwd              //读取密码</p><p>stty echo                                  //恢复回显</p><p>echo ""                                      //恢复回显后补一个空行</p><p>useradd "$username"</p><p>echo "$passwd" | passwd --stdin "$username"</p><p>[root@svr5 ~]# chmod +x user.sh          //添加执行权限</p><p>执行测试脚本user.sh，验证效果：</p><p>[root@svr5 ~]# ./user.sh</p><p>请输入用户名:  root                          //输入root，回车</p><p>请输入密码:                                   //输入1234567（不会显示），回车</p><p><br></p><h3>2.5 export</h3><p>功能：定义全局变量</p><p><br></p><h3>2.6Shell中的数值运算</h3><p>使用expr、$[ ]、let等整数运算工具：定义变量X=1234，然后计算X与78的四则运算及求模结果</p><p>使用bc实现小数运算操作：以交互方式计算12.34与56.78的四则运算结果，另外再以非交互方式重复上述计算，最多显示4位小数</p><h4>2.6.1整数运算工具</h4><p><b>1，使用expr命令</b></p><p>乘法操作应采用\*转义，避免被作为Shell通配符；参与运算的整数值与运算操作符之间需要以空格分开，引用变量时必须加$符号。</p><p>首先定义变量X=1234，然后分别计算与78的加减乘除和求模运算结果：</p><p>[root@svr5 ~]# X=1234                              //定义变量X</p><p>[root@svr5 ~]# expr  $X  +  88                      //加法</p><p>1322</p><p>[root@svr5 ~]# expr  $X  -  88                       //减法</p><p>1146</p><p>[root@svr5 ~]# expr  $X  \*  78                      //乘法，操作符应添加\转义</p><p>96252</p><p>[root@svr5 ~]# expr  $X  /  78                      //除法，仅保留整除结果</p><p>15</p><p>[root@svr5 ~]# expr  $X  %  78                     //求模</p><p>64</p><p><br></p><p><b>2，使用$[]或$(())表达式</b></p><p>乘法操作*无需转义，运算符两侧可以无空格；引用变量可省略 $ 符号；计算结果替换表达式本身，可结合echo命令输出。</p><p>同样对于变量X=1234，分别计算与78的加减乘除和求模运算结果：</p><p>[root@svr5 ~]# X=1234   </p><p>[root@svr5 ~]# echo $[X+78]</p><p>1312</p><p>[root@svr5 ~]# echo $[X-78]</p><p>1156</p><p>[root@svr5 ~]# echo $[X*78]</p><p>96252</p><p>[root@svr5 ~]# echo $[X/78]</p><p>15</p><p>[root@svr5 ~]# echo $[X%78]</p><p>64</p><p>[root@server0 ~]# echo $[x**2]                               #x=20   ,20的2次幂</p><p>400</p><p><b>3，使用let命令</b></p><p>expr或$[]、$(())方式只进行运算，并不会改变变量的值；而let命令可以直接对变量值做运算再保存新的值。因此变量X=1234，在执行let运算后的值会变更；另外，let运算操作并不显示结果，但是可以结合echo命令来查看：</p><p>[root@svr5 ~]# X=1234  </p><p>[root@svr5 ~]# let y=X+22</p><p>[root@svr5 ~]# echo $y</p><p>1256</p><p>[root@svr5 ~]# let X++;  echo $X        # X++(X=X+1)</p><p>[root@svr5 ~]# let X--;  echo $X        # X--(X=X-1)</p><p>[root@svr5 ~]# let X+=78 ; echo $X        # X+=78(X=X+78)</p><p>[root@svr5 ~]# let X-=78 ; echo $X     # X-=78(X=X-78)</p><p>[root@svr5 ~]# let X*=78 ; echo $X     # X*=78(X=X*78)</p><p>[root@svr5 ~]# let X/=78 ; echo $X     # X/=78(X=X/78)</p><p>[root@svr5 ~]# let X%=78 ; echo $X     # X%=78(X=X%78)</p><h4>2.6.2小数运算工具</h4><p><b>1，bc交互式运算</b></p><p>先执行bc命令进入交互环境，然后再输入需要计算的表达式。以计算小数12.34与5.678的四则运算为例，相关操作如下：</p><p>[root@svr5 ~]# bc</p><p>bc 1.06.95</p><p>Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc.</p><p>This is free software with ABSOLUTELY NO WARRANTY.</p><p>For details type `warranty'.</p><p>12.34+56.78                                        //加法</p><p>69.12</p><p>12.34-56.78                                        //减法</p><p>-44.44</p><p>12.34*56.78                                        //乘法</p><p>700.66</p><p>12.34/56.78                                        //除法</p><p>0</p><p>quit                                              //退出交互计算器</p><p>[root@svr5 ~]#</p><p><b>2，bc非交互式运算</b></p><p>将需要运算的表达式通过管道操作交给bc运算。注意，小数位的长度可采用scale=N限制，除此以外也受参与运算的数值的小数位影响。以计算小数12.34与5.678的四则运算为例，相关操作如下：</p><p>[root@svr5 ~]# echo 'scale=4;12.34+5.678' | bc</p><p>18.018</p><p>[root@svr5 ~]# echo 'scale=4;12.34*5.678' | bc</p><p>70.0665</p><p>[root@svr5 ~]# echo 'scale=4;12.34/5.678' | bc</p><p>2.1733</p><p><br></p><h3>2.7条件测试</h3><p>字符串匹配</p><p>比较整数值的大小</p><p>识别文件/目录的状态</p><p>多个条件/操作的逻辑组合</p><h4>2.7.1语法格式</h4><p>使用“test表达式”或者[ 表达式 ]都可以，表达式两边至少要留一个空格。</p><p>条件测试操作本身不显示出任何信息。测试的条件是否成立主要体现在命令执行后的返回状态（即$?），所以可以在测试后查看变量$?的值来做出判断，或者结合&amp;&amp;、||等逻辑操作显示出结果（或作其他操作） 。</p><p><br></p><p>==： 比较两个字符串是否相同</p><p>!=：比较两个字符串是否不相同</p><p><b>1，行执行多条命令的情况</b></p><p># A &amp;&amp; B                        //仅当A命令执行成功，才执行B命令</p><p># A || B                        //仅当A命令执行失败，才执行B命令</p><p># A ;  B                        //执行A命令后执行B命令，两者没有逻辑关系</p><p>-z检查变量的值是否未设置（空值）</p><p>[root@svr5 ~]# var1="nb" ; var2=""</p><p>[root@svr5 ~]# [ -z "$var1" ] &amp;&amp; echo "空值" || echo "非空值"</p><p>非空值</p><p>[root@svr5 ~]# [ -z $var2 ] &amp;&amp; echo "空值" || echo "非空值"</p><p>空值//变量var2已设置，但无任何值，视为空</p><p><br></p><p><b>2，整数值比较</b></p><p>-eq：比较两个数是否相等</p><p>-ne：比较两个数是否不相等</p><p>-gt：比较前面的整数是否大于后面的整数</p><p>-ge：比较前面的整数是否大于或等于后面的整数</p><p>-lt：比较前面的整数是否小于后面的整数</p><p>-le：比较前面的整数是否小于或等于后面的整数</p><p><b>3，识别文件/目录的状态</b></p><p>-e：判断对象是否存在（不管是目录还是文件）</p><p>-d：判断对象是否为目录（存在且是目录）</p><p>-f：判断对象是否为文件（存在且是文件）</p><p>-r：判断对象是否可读</p><p>-w：判断对象是否可写</p><p>-x：判断对象是否具有可执行权限</p><p><br></p><p><b>4，多个条件/操作的逻辑组合</b></p><p>--&amp;&amp;，逻辑与</p><p>给定条件必须都成立，整个测试结果才为真。</p><p>--||，逻辑或</p><p>只要其中一个条件成立，则整个测试结果为真。</p><h3>2.8条件，循环</h3><h4>2.8.1 if<br>
</h4><p>if条件测试|命令</p><p>fi</p><p><br></p><p>if条件测试</p><p>then</p><p>命令序列1</p><p>else  </p><p>命令序列2</p><p>fi</p><p><br></p><p>if条件测试1 ;then  </p><p>命令序列1</p><p>elif条件测试2 ;then  </p><p>命令序列2</p><p>else</p><p>命令序列n</p><p>fi</p><p><br></p><p><br></p><h4>2.8.2for</h4><p>RANDOM：产生随机数</p><p>random</p><p><br></p><p>for随便一个未定义变量  in  参数，列表，命令</p><p>do</p><p>done</p><p>1）{a..n}  ,seq n</p><p>{1..n}=`seq n`</p><p>区别：</p><p>{}里面不能有变量，seq 后可以是变量</p><p><br></p><p>for num in {a..n}                       #seq  n</p><p>do</p><p>done</p><p>例子：</p><p>#!/bin/bash</p><p>for i in {1..5}</p><p>do</p><p>  for j in {1..8}</p><p>  do</p><p>echo -n "* "                          #-n不换行</p><p>  done</p><p>echo                                          #默认换行</p><p>done</p><p><br></p><p>echo -e  ‘ \033[32mOK\033[0m’</p><p><br></p><p>2）命令执行结果(值列表)</p><p>for num in命令</p><p>do</p><p>done</p><p><br></p><p>for num in `cat  /etc/passwd`</p><p>do</p><p>  echo $num</p><p>done</p><p>3）（C语言风格的for循环语法格式）</p><p>[root@svr5 ~]# vim cfor.sh</p><p>#!/bin/bash</p><p>for ((i=1;i&lt;=5;i++))</p><p>do</p><p>   echo $i</p><p>done</p><p><br></p><p>4)break,continue,exit</p><p><br></p><h4>2.8.3while</h4><p>while条件测试</p><p>do</p><p>命令</p><p>done</p><p>常用死循环格式</p><p>while :</p><p>do</p><p>命令</p><p>done</p><p><br></p><p><br></p><h4>2.8.4case</h4><p>格式:</p><p>case变量值 in</p><p>模式1|模式5|模式6)</p><p>命令1;;</p><p>模式2)</p><p>命令2;;</p><p>*)</p><p>命令21</p><p>esac</p><p><br></p><h3>2.9设置输出字体颜色</h3><p>echo -e “\033[32mOK\033[0m”</p><p>0x： 样式</p><p>3x：字体色                      #31红色，32绿色</p><p>4x：背景色</p><p>10x：高亮色</p><p><br></p><h4>2.10函数</h4><p>unset函数名                              #取消函数名</p><p>wait :等待该脚本的程序执行完结束后回到命令行</p><p>语法格式：</p><p>1）标准格式</p><p>function函数名(){</p><p>n命令序列</p><p>}</p><p>2）常用</p><p>函数名(){</p><p>n命令序列</p><p>}</p><p><br></p><h3>2.11字符串</h3><h4>2.11.1字符串初值的处理</h4><p>${var:-word}</p><p>若变量var已存在且非Null，则返回 $var 的值；否则返回字串“word”，原变量var的值不受影响</p><h4>2.11.2字符串统计个数</h4><p>[root@room9pc01 ~]# p=123456</p><p>[root@room9pc01 ~]# echo ${#p}                     #统计变量长度</p><p>6</p><p><br></p><h4>2.11.3子串截取的三种用法</h4><p><b>1）${变量名:起始位置:长度}</b></p><p>提示：使用${}方式截取字符串时，起始位置是从0开始的</p><p>例子：</p><p>[root@room9pc01 ~]# p=123456</p><p>[root@room9pc01 ~]# echo ${#p}</p><p>6</p><p>[root@room9pc01 ~]# echo ${p:1:3}</p><p>234</p><p><br></p><p><b>2）expr substr "$变量名" 起始位置 长度</b></p><p>提示：使用expr substr截取字符串时，起始编号从1开始，这个要注意与${}相区分</p><p>例子：</p><p>[root@room9pc01 ~]# p=123456789</p><p>[root@room9pc01 ~]# expr substr "$p" 1 5</p><p>12345</p><p><br></p><p><b>3）echo $变量名 | cut -b 起始位置-结束位置</b></p><p>提示：选项-b表示按字节截取字符，其中起始位置、结束位置都可以省略。当省略起始位置时，视为从第1个字符开始（编号也是从1开始，与expr类似），当省略结束位置时，视为截取到最后。</p><p>例子：</p><p>[root@room9pc01 ~]# echo $p</p><p>123456789</p><p>[root@room9pc01 ~]# echo $p | cut -b 1-5</p><p>12345</p><p>[root@room9pc01 ~]# echo $p | cut -b 3-5</p><p>345</p><p>[root@room9pc01 ~]# echo $p | cut -b 3,5-6,8          #位置可连续，也可间断</p><p>3568</p><p><br></p><h4>2.11.4子串替换的两种用法</h4><p>1)只替换第一个匹配结果：${变量名/old/new}</p><p>2)替换全部匹配结果：${变量名//old/new}</p><p>例子：</p><p>[root@VM_0_2_centos ~]# name=55668855</p><p>[root@VM_0_2_centos ~]# echo ${name/5/cc}</p><p>cc5668855</p><p>[root@VM_0_2_centos ~]# echo ${name//5/cc}</p><p>cccc6688cccc</p><p><br></p><h4>2.11.5字符串掐头去尾</h4><p><b>1)从左向右，最短匹配删除：${变量名#*关键词}</b></p><p>[root@room9pc01 ~]# echo $A</p><p>root:x:0:0:root:/root:/bin/bash</p><p>[root@room9pc01 ~]# echo ${A#*:}</p><p>x:0:0:root:/root:/bin/bash</p><p><br></p><p><b>2)从左向右，最长匹配删除：${变量名##*关键词}</b></p><p>[root@room9pc01 ~]# echo $A</p><p>root:x:0:0:root:/root:/bin/bash</p><p>[root@room9pc01 ~]# echo ${A##*:}</p><p>/bin/bash</p><p><br></p><p><b>3)从右向左，最短匹配删除：${变量名%关键词*}</b></p><p>[root@room9pc01 ~]# echo $A</p><p>root:x:0:0:root:/root:/bin/bash</p><p>[root@room9pc01 ~]# echo ${A%:*}</p><p>root:x:0:0:root:/root</p><p><br></p><p><b>4)从右向左，最长匹配删除：${变量名%%关键词</b>*}</p><p>[root@room9pc01 ~]# echo $A</p><p>root:x:0:0:root:/root:/bin/bash</p><p>[root@room9pc01 ~]# echo ${A%%:*}</p><p>root</p><p><br></p><h3>2.12expect预期交互</h3><p>实现SSH登录的自动交互</p><p>expect可以为交互式过程（比如FTP、SSH等登录过程）自动输送预先准备的文本或指令，而无需人工干预。触发的依据是预期会出现的特征提示文本</p><p>#yum -y install expect</p><p><b>1）&lt;&lt;</b></p><p>[root@room9pc01下载]# mail -s jluo root &lt;&lt; EOF</p><p>&gt; dfsg</p><p>&gt; dgsd</p><p>&gt; dgs</p><p>&gt; EOF</p><p><br></p><p><b>2）非交互命令</b></p><p>ip=192.168.4.10</p><p>expect &lt;&lt; EOF</p><p>spawn ssh "$ip"</p><p>expect "password" { send "123456\n" }          #必须用双引号</p><p>expect "#"        { send "touch /test.txt\n"}</p><p>expect "#"        { send "exit \n"}</p><p>EOF</p><p>提示：必须要用双引号，单引号会出错</p><p><br></p><h3>2.13正则表达式</h3><p><br></p><div class="image-package">
<img class="uploaded-img" src="http://upload-images.jianshu.io/upload_images/17609428-0fbad83ce4540aad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="auto" height="auto"><br><div class="image-caption"></div>
</div><p>基本正则兼容性强，几乎所有的软件都支持，书写麻烦</p><p>扩展正则兼容性差</p><p>例子：</p><p>[root@room9pc01 shell-test]# egrep "the\b" test/a.txt</p><p>the sdfsdfsdfsf</p><p>dfsfsdf dsfsthe dfsdfdffg</p><p>gfgdg gfdfg the fgfgdf</p><p>[root@room9pc01 shell-test]# egrep "\bthe\b" test/a.txt</p><p>the sdfsdfsdfsf</p><p>gfgdg gfdfg the fgfgdf</p><h3>2.14sed</h3><p>Stream Editor流式编辑器</p><p>特点：</p><p>非交互式，基于模式匹配过滤及修改文本</p><p>逐行处理，并将结果输出到屏幕</p><p>可实现对文本的输出，删除，替换，复制，剪切，导入，导出等各种操作</p><h4>2.14.1用法</h4><p>用法1：前置命令 | sed  [选项]  '条件指令'</p><p>用法2：sed  [选项]  '条件指令'  文件.. ..</p><p><br></p><p>条件可以是行号或者/正则/</p><p>没有条件时，默认为所有条件</p><p>指令可以是增、删、改、查等指令</p><p>默认sed会将所有输出的内容都打印出来，可以使用-n屏蔽默认输出</p><p>选项中可以使用-r选项，让sed支持扩展正则</p><p><br></p><p><b>1，认识sed工具的基本选项</b></p><p>sed命令的常用选项如下：</p><p>-n（屏蔽默认输出，默认sed会输出读取文档的全部内容）</p><p>-r（让sed支持扩展正则）</p><p>-i（sed直接修改源文件，默认sed只是通过内存临时修改文件，源文件无影响）</p><p><br></p><p><b>2，常用的动作指令(条件指令)</b></p><p>p：打印行</p><p>d：删除行</p><p>s：字符替换</p><div class="image-package">
<img class="uploaded-img" src="http://upload-images.jianshu.io/upload_images/17609428-b39881aab7d993b7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="auto" height="auto"><br><div class="image-caption"></div>
</div><p>注意：替换操作的分隔“/”可改用其他字符，如#、&amp;等，便于修改文件路径</p><p><br></p><p><b>3，sed工具的多行文本处理操作</b></p><p>i： 在指定的行之前插入文本  insert   </p><p>a：在指定的行之后追加文本  append</p><p>c：替换指定的行                    </p><p>r:读取</p><p>w:另存</p><p><br></p><p>例子：</p><p>##</p><p>[root@room9pc01 shell-test]# sed '2r user.txt' test.txt</p><p>              hello</p><p>2017 2011 2018</p><p>aa</p><p>bb</p><p>2017 2017 2024</p><p>2017 2017 2017</p><p>2245fdsfdf</p><p>##</p><p>[root@room9pc01 shell-test]# sed 'w user' test.txt</p><p>              hello</p><p>2017 2011 2018</p><p>2017 2017 2024</p><p>2017 2017 2017</p><p>2245fdsfdf</p><p>[root@room9pc01 shell-test]# cat user</p><p>              hello</p><p>2017 2011 2018</p><p>2017 2017 2024</p><p>2017 2017 2017</p><p>2245fdsfdf</p><p>##</p><p>[root@room9pc01 shell-test]# sed '2w user' test.txt</p><p>              hello</p><p>2017 2011 2018</p><p>2017 2017 2024</p><p>2017 2017 2017</p><p>2245fdsfdf</p><p>[root@room9pc01 shell-test]# cat user</p><p>2017 2011 2018</p><p>##</p><p>[root@svr5 ~]# sed  '3,5d' a.txt             //删除第3~5行</p><p>[root@svr5 ~]# sed  '/xml/d' a.txt            //删除所有包含xml的行</p><p>[root@svr5 ~]# sed  '/xml/!d' a.txt         //删除不包含xml的行，!符号表示取反</p><p>[root@svr5 ~]# sed  '/^install/d' a.txt    //删除以install开头的行</p><p>[root@svr5 ~]# sed  '$d' a.txt                //删除文件的最后一行</p><p>[root@svr5 ~]# sed  '/^$/d' a.txt             //删除所有空行</p><p>##</p><p>1~2p：1 1+2=3 3+3=5 …..</p><p>2~2p：2 2+2=4 4+2=6 …..</p><p>打印奇数行：</p><p>[root@svr5 ~]# sed -n '1~2p' /etc/passwd</p><p>打印偶数行：</p><p>[root@svr5 ~]# sed -n '2~2p' /etc/passwd</p><p>##</p><p>[root@room9pc01 shell-test]# sed -n 's#/bin/bash#/sbin/sh#gp' passwd</p><p>root:x:0:0:root:/root:/sbin/sh</p><p>Student:x:1000:1000::/home/Student:/sbin/sh</p><p>xiaohei:x:1002:1001::/sbin/nologin:/sbin/sh</p><p>注意：替换操作的分隔“/”可改用其他字符，如#、&amp;等，便于修改文件路径</p><p>##</p><p>[root@svr5 ~]# vim anonftp.sh</p><p>#!/bin/bash</p><p>yum -y install vsftpd                             //安装vsftpd软件</p><p>cp /etc/vsftpd/vsftpd.conf{,.bak}                  //备份默认的配置文件</p><p>sed -i "s/^#anon/anon/" /etc/vsftpd/vsftpd.conf      //修改服务配置</p><p>chmod 777 /var/ftp/pub                              //调整目录权限</p><p>systemctl start vsftpd                              //启动服务</p><p>systemctl enable vsftpd                            //设为自动运行</p><p>[root@svr5 ~]# chmod +x anonftp.sh</p><p>[root@svr5 ~]# ./anonftp.sh</p><p><br></p><p><b>4，sed复制剪切</b></p><p>H：模式空间 –[追加] --&gt;保持空间</p><p>h：模式空间 –[覆盖] --&gt;保持空间</p><p>G：保持空间 –[追加] --&gt;模式空间</p><p>g：保持空间 –[覆盖]  --&gt;模式空间</p><p>例子：</p><p>##</p><p>[root@room9pc01 shell-test]# sed '2h;5g' 10.txt</p><p>1</p><p>2</p><p>3</p><p>4</p><p>2</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>##</p><p>[root@room9pc01 shell-test]# sed '2H;5G' 10.txt</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p><br></p><p>2</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>##</p><p>[root@room9pc01 shell-test]# sed '2h;5G' 10.txt</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>2</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p><br></p><h3>2.15awk</h3><p>awk编程语言/数据处理引擎</p><p>Aho Weinberger Kernighan</p><p>特点：</p><p>通常用在shell脚本中，获取指定的数据</p><p>单独使用时，可对文本数据做统计</p><p>用于过滤数据</p><p>逐行处理</p><h4>2.15.1用法</h4><p>格式1：前置命令 | awk [选项] ‘[条件]{指令}’</p><p>格式2：awk [选项] ‘[条件]{指令}’  文件….</p><p>提示：引号只能是单引号</p><p><br></p><h4>2.15.2基本操作方法</h4><p>格式：awk [选项] '[条件]{指令}' 文件</p><p>其中，print是最常用的编辑指令；若有多条编辑指令，可用分号分隔。</p><p>Awk过滤数据时支持仅打印某一列，如第2列、第5列等。</p><p>处理文本时，若未指定分隔符，则默认将空格、制表符等作为分隔符。</p><p>[root@svr5 ~]# df -h | awk '{print $4}'        //打印磁盘的剩余空间</p><p><br></p><h4>2.15.3选项 -F 可指定分隔符</h4><p>[root@svr5 ~]# awk -F: '{print $1,$7}' /etc/passwd</p><p>root /bin/bash</p><p>bin /sbin/nologin</p><p>daemon /sbin/nologin</p><p>awk还识别多种单个的字符，比如以“:”或“/”分隔，输出第1、10个字段</p><p>[root@svr5 ~]# awk -F [:/] '{print $1,$10}' /etc/passwd</p><p>root bash</p><p>bin nologin</p><p>daemon nologin</p><p>adm sbin</p><p>… …</p><p><br></p><h4>2.15.4awk常用内置变量</h4><p>$0文本当前行的全部内容</p><p>$1	文本的第1列</p><p>$2	文件的第2列</p><p>$3	文件的第3列，依此类推</p><p>NR	文件当前行的行号</p><p>NF	文件当前行的列数（有几列）</p><p><br></p><p><br></p><p><br></p><p><br></p><h4>2.15.5awk处理的时机</h4><p>BEGIN{ }	行前处理，读取文件内容前执行，指令执行1次</p><p>{ }	逐行处理，读取文件过程中执行，指令执行n次</p><p>END{ }	行后处理，读取文件结束后执行，指令执行1次</p><p><br></p><p>格式：awk ‘BEGIN{}条件{}END{}’</p><p>提示：字符串里面要用双引号</p><p>输出信息时，可以使用“\t”显示Tab制表位：</p><p>##</p><p>[root@room9pc01 shell-test]# awk -F: 'BEGIN{print "User","UID","Home"}{print $1,$3,$6}END{print "Total",NR,"lines"}' /etc/passwd | column -t</p><p>User                 UID    Home</p><p>root                 0      /root</p><p>bin                  1      /bin</p><p>daemon               2      /sbin</p><p>column -t：把数据对齐显示</p><p>##</p><p>[root@room9pc01 shell-test]# awk 'BEGIN{print "begin"}{}END{print "end"}' test.txt  </p><p>begin</p><p>end</p><p>##</p><p>[root@room9pc01 shell-test]# awk "BEGIN{x=0}/bash$/{x++}END{print x}" /etc/passwd</p><p>3</p><p><br></p><h4>2.15.6awk处理条件</h4><p><br></p><p>##正则设置条件</p><p>输出账户名称包含root的基本信息（第1列包含root）：</p><p>[root@svr5 ~]# awk -F: '$1~/root/' /etc/passwd</p><p>输出其中登录Shell不以nologin结尾（对第7个字段做!~反向匹配）的用户名、登录Shell信息：</p><p>[root@svr5 ~]# awk -F: '$7!~/nologin$/{print $1,$7}' /etc/passwd</p><p>root /bin/bash</p><p>sync /bin/sync</p><p>shutdown /sbin/shutdown</p><p><br></p><p>##数值/字符串比较设置条件</p><p>比较符号：==(等于) !=（不等于） &gt;（大于）</p><p>&gt;=（大于等于） &lt;（小于） &lt;=（小于等于）</p><p>&amp;&amp;    ||</p><p><br></p><p><br></p><p><br></p><h4>2.15.7awk流程控制</h4><p>if分支结构（单分支、双分支、多分支）</p><p>练习awk数组的使用</p><p>##awk过滤中的if分支结构</p><p>if (条件){</p><p>}</p><p>else if(条件){</p><p>}</p><p>else{</p><p>}</p><p><br></p><p>##awk数组</p><p>数组是一个可以存储多个值的变量，具体使用的格式如下：</p><p>定义数组的格式：数组名[下标]=元素值</p><p>调用数组的格式：数组名[下标]</p><p>遍历数组的用法：for(变量 in 数组名){print 数组名[变量]}。</p><p>[root@svr5 ~]# awk 'BEGIN{a[0]=11;a[1]=88;print a[1],a[0]}'</p><p>88 11</p><p>[root@svr5 ~]# awk 'BEGIN{a++;print a}'</p><p>1</p><p>[root@svr5 ~]# awk 'BEGIN{a0++;print a0}'</p><p>1</p><p>[root@svr5 ~]# awk 'BEGIN{a[0]++;print a[0]}'</p><p>1</p><p>[root@svr5 ~]# awk 'BEGIN{a[0]=0;a[1]=11;a[2]=22; for(i in a){print i,a[i]}}'</p><p>0 0</p><p>1 11</p><p>2 22</p><p>注意，awk数组的下标除了可以使用数字，也可以使用字符串，字符串需要使用双引号：</p><p>[root@svr5 ~]# awk 'BEGIN{a["hehe"]=11;print a["hehe"]}'</p><p>11</p><h4>2.15.8awk扩展应用</h4><p>需求：</p><p>分析Web日志的访问量排名，要求获得客户机的地址、访问次数，并且按照访问次数排名</p><p>思路：</p><p>awk统计Web访问排名</p><p>在分析Web日志文件时，每条访问记录的第一列就是客户机的IP地址，其中会有很多重复的IP</p><p>地址。因此只用awk提取出这一列是不够的，还需要统计重复记录的数量并且进行排序。</p><p>通过awk提取信息时，利用IP地址作为数组下标，每遇到一个重复值就将此数组元素递增1，最</p><p>终就获得了这个IP地址出现的次数。</p><p>针对文本排序输出可以采用sort命令，相关的常见选项为-r、-n、-k。其中-n表示按数字顺序</p><p>升序排列，而-r表示反序，-k可以指定按第几个字段来排序。</p><p>统计Web访问量排名</p><p><b>1）提取IP地址及访问量</b></p><p>[ root@sv r5 ~] # awk '{ ip[ $1] ++} \</p><p>&gt; END{ for( i in ip) { print ip[ i] ,i } } ' /var/log/httpd/access_log</p><p>4 127.0.0.1</p><p>17 192.168.4.5</p><p>13 192.168.4.110</p><p>. .. ..</p><p><b>2）对第1）步的结果根据访问量排名</b></p><p> [ root@sv r5 ~] # awk '{ ip[ $1] ++} END{ for( i in ip) { print ip[ i],i } } ' /var/log/httpd/access_log | sort -rn</p><p>17 192.168.4.5</p><p>13 192.168.4.110</p><p>4 127.0.0.1</p><h1>三总结</h1><p>本次教程主要是记录shell的基本语法以及wak，sed工具的基本使用，简单易学。</p><p><br></p><p><b>温馨提示：</b></p><p>本次教程仅供参考，若有不足之处望方家指正，谢谢。</p><p><br></p><p><br></p><hr><p><b>结束语：</b></p><p>更多精彩内容持续更新中，<b>关注我</b>，有你更精彩。</p>
        </div>
      </div>
    </div>
  </body>
</html>
